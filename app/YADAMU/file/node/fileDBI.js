"use strict" 
const fs = require('fs');
const path = require('path');

const Yadamu = require('../../common/yadamu.js');
const YadamuDBI = require('../../common/yadamuDBI.js');
const FileWriter = require('./fileWriter.js');
const JSONParser = require('./jsonParser.js');
const EventManager = require('./eventManager.js')
/*
**
** YADAMU Database Inteface class skeleton
**
*/

class FileDBI extends YadamuDBI {
 
  /*
  **
  ** !!! For the FileDBI an export operaton involves reading data from the file system and an Import operation involves writing data to the file system !!!
  **
  */

  constructor(yadamu,exportFilePath) {
    super(yadamu)
	this.exportFilePath = exportFilePath
    this.outputStream = undefined;
    this.inputStream = undefined;
	this.ddl = undefined;
    this.tableSeperator = '';
  }

  generateStatementCache() {
	this.statementCache = {}
  }
      
  async executeDDL(ddl) {
    this.outputStream.write(',');
    this.outputStream.write(`"ddl":${JSON.stringify(ddl)}`);
  }
  
  getConnectionProperties() {
    return {}
  }
  
  exportComplete(message) {
	this.eventManager.exportComplete(message);
  }
  
  closeInputStream() {      
    this.inputStream.close();
  }

  closeOutputStream() {
     return new Promise((resolve,reject) => {
      this.outputStream.on('finish',() => { resolve() });
      this.outputStream.close();
    })

  }
  
  // Override YadamuDBI - Any DDL is considered valid and written to the export file.
  
  isValidDDL() {
    return true;
  }
  
  // Override YadamuDBI
  
  isDatabase() {
    return false;
  }
  
  // Override YadamuDBI

  objectMode() {
     return false;  
  }

  async getMetadata() {
	return []
  }
  
  async getSystemInformation() {
	return {}
  }

  async setSystemInformation(systemInformation) {
	super.setSystemInformation(systemInformation) 
    if (this.outputStream !== undefined) {
      this.outputStream.write(`"systemInformation":${JSON.stringify(this.systemInformation)}`);
	}
  }
  
  async writeMetadata(metadata) {
     if (this.outputStream !== undefined) {
 	  this.outputStream.write(',');
      this.outputStream.write(`"metadata":${JSON.stringify(this.metadata)}`);
	}
  }
  
  async setMetadata(metadata) {
    Object.values(metadata).forEach((table) => {delete table.source})
	super.setMetadata(metadata)
    await this.writeMetadata(metadata)
  }
 
  get DATABASE_VENDOR()    { return 'FILE' };
  get SOFTWARE_VENDOR()    { return 'YABASC' };

  async releaseConnection() {
  }
 
  async initialize() {
    super.initialize(false);
    this.spatialFormat = this.parameters.SPATIAL_FORMAT ? this.parameters.SPATIAL_FORMAT : super.SPATIAL_FORMAT
	this.exportFilePath = this.exportFilePath === undefined ? this.parameters.FILE : this.exportFilePath
	this.exportFilePath =  path.resolve(this.exportFilePath)
  }

  async initializeExport() {
	// this.yadamuLogger.trace([this.constructor.name],`initializeExport()`)
	super.initializeExport();
    await new Promise((resolve,reject) => {
      this.inputStream = fs.createReadStream(this.exportFilePath);
      this.inputStream.on('open',() => {resolve()}).on('error',(err) => {reject(err)})
    })
  }

  async finalizeExport() {
 	// this.yadamuLogger.trace([this.constructor.name,],'finalizeExport()')
	this.closeInputStream()
  }
  
  async initializeImport() {
	// For FileDBI Import is Writing data to the file system.
    // this.yadamuLogger.trace([this.constructor.name],`initializeImport()`)
	super.initializeImport()
    this.outputStream = fs.createWriteStream(this.exportFilePath);
    this.yadamuLogger.info([this.DATABASE_VENDOR],`Writing file "${this.exportFilePath}".`)
	this.outputStream.write(`{`)
  }
  
  async initializeData() {
    this.outputStream.write(',');
    this.outputStream.write('"data":{'); 
  }
  
  async finalizeData() {
	// this.yadamuLogger.trace([this.constructor.name],`finalizeData()`)
	this.outputStream.write('}');
  }  
  
  async finalizeImport() {
    // this.yadamuLogger.trace([this.constructor.name],`finalizeImport()`)
	this.outputStream.write('}');
  }
    
  async finalize() {
    if (this.inputStream !== undefined) {
      await this.closeInputStream()
    }
    if (this.outputStream !== undefined) {
      await this.closeOutputStream()
    }
  }


  /*
  **
  **  Abort the database connection.
  **
  */

  async abort() {

    try {
      if (this.inputStream !== undefined) {
        await this.closeInputStream()
	  }
    } catch (err) {
      this.yadamuLogger.handleException([`${this.DATABASE_VENDOR}`,'ABORT','InputStream'],err);
    }
	 
    try {
      if (this.outputStream !== undefined) {
        await this.closeOutputStream()
	  }
    } catch (err) {
      this.yadamuLogger.handleException([`${this.DATABASE_VENDOR}`,'ABORT','OutputStream'],err);
    }
  }

  /*
  **
  **  Generate a set of DDL operations from the metadata generated by an Export operation
  **
  */
  
      
  async generateStatementCache(schema,executeDDL) {

    this.statementCache = []
  }

  async getDDLOperations() {
    return []
  }
  
  async getSchemaInfo(schema) {
    return []
  }
  
  getTableInfo(tableName) {
	
    if (tableName === null) {
	  // Hack to enable statisticsCollector to use the YadamuWriter interface to collect statistics about the cotnents of a YADAMU export file...
      return {}
    }
	 
	// ### Need to simplify and standardize DataTypes - Data type mapping for Files.. 
	
	// Include a dummy dataTypes array of the correct length to ensure the column count assertion does not throw
	return { 
	  tableName       : tableName
	, _SPATIAL_FORMAT : this.systemInformation.spatialFormat
    , columnNames     : [... this.metadata[tableName].columnNames]
    , targetDataTypes : [... this.metadata[tableName].dataTypes]
    }
  }

  getInputStream() {  
    // Return an Event Stream based on processing the inputStream with the JSONParser class
    const stats = fs.statSync(this.exportFilePath)
    const fileSizeInBytes = stats.size
    this.yadamuLogger.info([this.DATABASE_VENDOR],`Processing file "${this.exportFilePath}". Size ${fileSizeInBytes} bytes.`)
    const jsonParser  = new JSONParser(this.yadamuLogger,this.MODE);
    const eventManager = new EventManager(this.yadamu)
	this.eventStream = this.inputStream.pipe(jsonParser).pipe(eventManager)
	return this.eventStream;
  }
    
  getOutputStream(tableName) {
    // this.yadamuLogger.trace([this.constructor.name],`getOutputStream(${tableName},${this.firstTable})`)
    // Override parent method to allow output stream to be passed to worker
    // return super.getOutputStream(FileWriter,primary)
	this.outputStream.write(`${this.tableSeperator}"${tableName}":`);
	const os =  new FileWriter(this,tableName,this.status,this.yadamuLogger,this.outputStream)
	this.tableSeperator = ',';
    return os;
  }
  
}

module.exports = FileDBI

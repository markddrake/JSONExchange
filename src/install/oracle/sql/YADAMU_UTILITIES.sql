create or replace package YADAMU_UTILITIES
authid CURRENT_USER
as
--
  JSON_OVERFLOW1 EXCEPTION; 
  PRAGMA EXCEPTION_INIT (JSON_OVERFLOW1, -40478);
  
  JSON_OVERFLOW2 EXCEPTION; 
  PRAGMA EXCEPTION_INIT (JSON_OVERFLOW2, -40459);

  JSON_OVERFLOW3 EXCEPTION; 
  PRAGMA EXCEPTION_INIT (JSON_OVERFLOW3, -46077);

  BUFFER_OVERFLOW EXCEPTION; 
  PRAGMA EXCEPTION_INIT (BUFFER_OVERFLOW, -22835);
    
  C_NULL    CONSTANT NUMBER(1) := 0;
  C_BOOLEAN CONSTANT NUMBER(1) := 1;
  C_NUMERIC CONSTANT NUMBER(1) := 2;
  C_STRING  CONSTANT NUMBER(1) := 3;
  C_CLOB    CONSTANT NUMBER(1) := 4;
  C_JSON    CONSTANT NUMBER(1) := 5;

  C_NEWLINE         CONSTANT CHAR(1) := CHR(10);
  C_CARRIAGE_RETURN CONSTANT CHAR(1) := CHR(13);
  C_SINGLE_QUOTE    CONSTANT CHAR(1) := CHR(39);

  function CLOBTOBLOB(P_CLOB IN CLOB, P_CHARSET VARCHAR2 DEFAULT 'AL32UTF8') return BLOB;
--
$IF NOT YADAMU_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
--
  TYPE KVP_RECORD is RECORD (
    KEY               VARCHAR2(4000)
   ,DATA_TYPE         NUMBER
   ,NUMERIC_VALUE     NUMBER
   -- ,BOOLEAN_VALUE     BOOLEAN
    $IF YADAMU_FEATURE_DETECTION.EXTENDED_STRING_SUPPORTED $THEN
   ,STRING_VALUE      VARCHAR2(32767)
    $ELSE
   ,STRING_VALUE      VARCHAR2(4000)
    $END
   ,CLOB_VALUE        CLOB
  );
  
  TYPE KVP_TABLE is TABLE of KVP_RECORD;
  
  function KVNUL(KEY VARCHAR2) return KVP_RECORD;
  function KVB(KEY VARCHAR2,VALUE BOOLEAN) return KVP_RECORD;
  function KVN(KEY VARCHAR2,VALUE NUMBER) return KVP_RECORD;
  function KVS(KEY VARCHAR2,VALUE VARCHAR2) return KVP_RECORD;
  function KVC(KEY VARCHAR2,VALUE CLOB) return KVP_RECORD;  
  function KVJ(KEY VARCHAR2,VALUE CLOB) return KVP_RECORD;

  TYPE JSON_ARRAY_TABLE is TABLE OF CLOB;
  TYPE KVP_TABLE_TABLE  is TABLE OF KVP_TABLE;
  
  function JSON_ARRAY_CLOB(P_ARRAY_ENTRIES KVP_TABLE) return CLOB;
  function JSON_OBJECT_CLOB(P_KVP_LIST KVP_TABLE) return CLOB;
  function JSON_ARRAYAGG_CLOB(P_CURSOR SYS_REFCURSOR) return CLOB;
  function JSON_ARRAYAGG_CLOB(P_JSON_ARRAYS JSON_ARRAY_TABLE) return CLOB;  function JSON_ARRAYAGG_CLOB(P_ARRAY_ARRAY_ENTRIES KVP_TABLE_TABLE) return CLOB;
  function JSON_OBJECTAGG_CLOB(P_STATEMENT VARCHAR2) return CLOB;
  
--
$END
--  
END;
/
--
set TERMOUT on
--
show errors
--
@@SET_TERMOUT
--
create or replace package body YADAMU_UTILITIES
as
--
function CLOBTOBLOB(P_CLOB IN CLOB, P_CHARSET VARCHAR2 DEFAULT 'AL32UTF8') 
return BLOB 
as
  V_BLOB           BLOB;
  V_WARNING        VARCHAR2(255);
  V_CHARSET_ID     NUMBER := NLS_CHARSET_ID(P_CHARSET);
  V_DEST_OFFSET    NUMBER := 1; 
  V_SRC_OFFSET     NUMBER := 1; 
  V_LANG_CONTEXT   NUMBER := 0; 
begin
   DBMS_LOB.CREATETEMPORARY(V_BLOB, TRUE );
   DBMS_LOB.CONVERTTOBLOB(V_BLOB, P_CLOB, DBMS_LOB.LOBMAXSIZE, V_DEST_OFFSET, V_SRC_OFFSET, V_CHARSET_ID, V_LANG_CONTEXT, V_WARNING);
   RETURN V_BLOB; 
end;
--
$IF YADAMU_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
$ELSE
--
function JSON_ESCAPE(V_CHUNK VARCHAR2) 
return VARCHAR2
as
begin
  return REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(V_CHUNK,'\','\\') ,'"','\"'),CHR(13),'\n'),CHR(10),'\r'),CHR(9),'\t');
end;
--
function KVNUL(KEY VARCHAR2) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  KVP.DATA_TYPE := C_NULL;
  KVP.KEY := KEY;
  return KVP;
end;
--
function KVB(KEY VARCHAR2, VALUE BOOLEAN) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_BOOLEAN;
  KVP.KEY := KEY;
  -- KVP.BOOLEAN_VALUE := VALUE;
  KVP.NUMERIC_VALUE := CASE WHEN VALUE THEN 1 ELSE 0 END;
  return KVP;
end;
--
function KVN(KEY VARCHAR2, VALUE NUMBER) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_NUMERIC;
  KVP.KEY := KEY;
  KVP.NUMERIC_VALUE := VALUE;
  return KVP;
end;
--
function KVJ(KEY VARCHAR2, VALUE CLOB) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_JSON;
  KVP.KEY := KEY;
  KVP.CLOB_VALUE := VALUE;
  return KVP;
end;
--
function KVC(KEY VARCHAR2, VALUE CLOB) 
return KVP_RECORD
as
  V_VALUE_LENGTH PLS_INTEGER := DBMS_LOB.getLength(VALUE);
  KVP KVP_RECORD;

  V_CHUNK_START  NUMBER := 1;

  $IF YADAMU_FEATURE_DETECTION.JSON_GENERATION_SUPPORTED $THEN
  $IF YADAMU_FEATURE_DETECTION.EXTENDED_STRING_SUPPORTED $THEN
  V_CHUNK           VARCHAR2(32767);
  V_CHUNK_ESCAPED   VARCHAR2(32767);
  $ELSE
  V_CHUNK           VARCHAR2(4000);
  V_CHUNK_ESCAPED   VARCHAR2(4000);
  $END
  V_CHUNK_SIZE      NUMBER := YADAMU_FEATURE_DETECTION.C_MAX_STRING_SIZE-4;
  $ELSE
  V_CHUNK           VARCHAR2(8192);
  V_CHUNK_ESCAPED   VARCHAR2(32767);
  V_CHUNK_SIZE      NUMBER := 8192;
  $END
  
  
begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_CLOB;
  KVP.KEY := KEY;
  -- Use JSON_ARRAY to create properly escapaed value of string content
  -- Write the Array Content (which is correctly escaped JSON) into the buffer.
  -- Strip the [" and "] from the escaped value.
  DBMS_LOB.CREATETEMPORARY(KVP.CLOB_VALUE,TRUE,DBMS_LOB.SESSION);
  while (V_CHUNK_START < V_VALUE_LENGTH) loop
    DBMS_LOB.READ(VALUE,V_CHUNK_SIZE,V_CHUNK_START,V_CHUNK);
    $IF YADAMU_FEATURE_DETECTION.JSON_GENERATION_SUPPORTED $THEN
    begin
      --
      select JSON_ARRAY(V_CHUNK) 
        into V_CHUNK_ESCAPED
        from DUAL;
      DBMS_LOB.WRITEAPPEND(KVP.CLOB_VALUE,LENGTH(V_CHUNK_ESCAPED)-4,TRIM('"' FROM LTRIM(RTRIM(V_CHUNK_ESCAPED,']'),'[')));
      --
    exception
      when JSON_OVERFLOW1 or JSON_OVERFLOW2 then
        select JSON_ARRAY(SUBSTR(V_CHUNK,1,FLOOR(YADAMU_FEATURE_DETECTION.C_MAX_STRING_SIZE/2))) 
          into V_CHUNK_ESCAPED
          from DUAL;
        DBMS_LOB.WRITEAPPEND(KVP.CLOB_VALUE,LENGTH(V_CHUNK_ESCAPED)-4,TRIM('"' FROM LTRIM(RTRIM(V_CHUNK_ESCAPED,']'),'[')));
        --
        if (LENGTH(V_CHUNK) > FLOOR(YADAMU_FEATURE_DETECTION.C_MAX_STRING_SIZE/2)) then 
          select JSON_ARRAY(SUBSTR(V_CHUNK,CEIL(YADAMU_FEATURE_DETECTION.C_MAX_STRING_SIZE/2))) 
               into V_CHUNK_ESCAPED
              from DUAL;
          DBMS_LOB.WRITEAPPEND(KVP.CLOB_VALUE,LENGTH(V_CHUNK_ESCAPED)-4,TRIM('"' FROM LTRIM(RTRIM(V_CHUNK_ESCAPED,']'),'[')));
        end if;
      when OTHERS then
        RAISE;
     --
    end;
    --
    V_CHUNK_START := V_CHUNK_START + V_CHUNK_SIZE;
    V_CHUNK_SIZE := YADAMU_FEATURE_DETECTION.C_MAX_STRING_SIZE-4;
    -- 
    $ELSE
    --
    V_CHUNK_ESCAPED := JSON_ESCAPE(V_CHUNK);
    DBMS_LOB.WRITEAPPEND(KVP.CLOB_VALUE,LENGTH(V_CHUNK_ESCAPED),V_CHUNK_ESCAPED);
    V_CHUNK_START := V_CHUNK_START + V_CHUNK_SIZE;
    V_CHUNK_SIZE := 8192;
    --
    $END
    --
  end loop;  
  return KVP;
end;
--
function KVS(KEY VARCHAR2, VALUE VARCHAR2) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_STRING;
  KVP.KEY := KEY;
  -- Use JSON_ARRAY to create properly escapaed value of string content
  -- Write the Array Content (which is correctly escaped JSON) into the buffer.
  -- Strip the [" and "] from the escaped value.

  --
  $IF YADAMU_FEATURE_DETECTION.JSON_GENERATION_SUPPORTED $THEN
  select TRIM('"' FROM LTRIM(RTRIM(JSON_ARRAY(VALUE),']'),'['))
    into KVP.STRING_VALUE
    from DUAL;
  $ELSE
  KVP.STRING_VALUE := JSON_ESCAPE(VALUE);
  $END
  --
  return KVP;

exception
  when JSON_OVERFLOW1 or JSON_OVERFLOW2 then
    return KVC(KEY, VALUE);
  when OTHERS then
    RAISE;
end;
--
procedure WRITE_VALUE(P_JSON_DOCUMENT IN OUT CLOB,P_KVP KVP_RECORD)
as
begin
  case 
    when P_KVP.DATA_TYPE = C_NULL then
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length('null'),'null');  
    when P_KVP.DATA_TYPE = C_BOOLEAN and not P_KVP.NUMERIC_VALUE = 0 then
    -- when P_KVP.DATA_TYPE = C_BOOLEAN and P_KVP.BOOLEAN_VALUE then
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length('true'),'true');  
    when P_KVP.DATA_TYPE = C_BOOLEAN and P_KVP.NUMERIC_VALUE = 0 then
    -- when P_KVP.DATA_TYPE = C_BOOLEAN and not P_KVP.BOOLEAN_VALUE then
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length('false'),'false');  
    when P_KVP.DATA_TYPE = C_NUMERIC then
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length(TO_CHAR(P_KVP.NUMERIC_VALUE)),TO_CHAR(P_KVP.NUMERIC_VALUE));
    when P_KVP.DATA_TYPE = C_JSON then
      DBMS_LOB.APPEND(P_JSON_DOCUMENT,P_KVP.CLOB_VALUE);
    when P_KVP.DATA_TYPE = C_STRING then
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
      DBMS_LOB.APPEND(P_JSON_DOCUMENT,P_KVP.STRING_VALUE);
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
    when P_KVP.DATA_TYPE = C_CLOB then
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
      DBMS_LOB.APPEND(P_JSON_DOCUMENT,P_KVP.CLOB_VALUE);
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
  end case;
end;
--
procedure JSON_OBJECT_CLOB(P_JSON_DOCUMENT IN OUT CLOB, P_KVP_LIST KVP_TABLE)
as
begin
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'{');  
  if (P_KVP_LIST.count > 0) then
    for i in P_KVP_LIST.FIRST .. P_KVP_LIST.LAST loop
      if (i > 1) then DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,','); end if;  
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length(P_KVP_LIST(i).KEY),P_KVP_LIST(i).KEY);  
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,':');  
      WRITE_VALUE(P_JSON_DOCUMENT,P_KVP_LIST(i));
    end loop;
  end if;
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'}');  
end;
--
function  JSON_OBJECT_CLOB(P_KVP_LIST KVP_TABLE)
return CLOB
as
  V_RESULT CLOB;
begin
  DBMS_LOB.CREATETEMPORARY(V_RESULT,TRUE,DBMS_LOB.SESSION);
  JSON_OBJECT_CLOB(V_RESULT,P_KVP_LIST);
  return V_RESULT;
end;
--
procedure JSON_ARRAY_CLOB(P_JSON_DOCUMENT IN OUT CLOB, P_ARRAY_ENTRIES KVP_TABLE)
as
begin
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'[');  
  if (P_ARRAY_ENTRIES.count > 0) then
    for i in P_ARRAY_ENTRIES.FIRST .. P_ARRAY_ENTRIES.LAST loop
      if (i > 1) then DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,','); end if;  
      WRITE_VALUE(P_JSON_DOCUMENT,P_ARRAY_ENTRIES(i));
    end loop;
  end if;
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,']');  
end;
--
function  JSON_ARRAY_CLOB(P_ARRAY_ENTRIES KVP_TABLE)
return CLOB
as
  V_RESULT CLOB;
begin
  DBMS_LOB.CREATETEMPORARY(V_RESULT,TRUE,DBMS_LOB.SESSION);
  JSON_ARRAY_CLOB(V_RESULT,P_ARRAY_ENTRIES);
  return V_RESULT;
end;
--
procedure JSON_ARRAYAGG_CLOB(P_JSON_DOCUMENT IN OUT CLOB, P_ARRAY_ARRAY_ENTRIES KVP_TABLE_TABLE)
as
begin
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'[');  
  if (P_ARRAY_ARRAY_ENTRIES.count > 0) then
    for i in P_ARRAY_ARRAY_ENTRIES.FIRST .. P_ARRAY_ARRAY_ENTRIES.LAST loop
      if (i > 1) then DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,','); end if;  
      JSON_ARRAY_CLOB(P_JSON_DOCUMENT,P_ARRAY_ARRAY_ENTRIES(i));
    end loop;
  end if;
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,']');  
end;
--
function  JSON_ARRAYAGG_CLOB(P_ARRAY_ARRAY_ENTRIES KVP_TABLE_TABLE)
return CLOB
as
  V_RESULT CLOB;
begin
  DBMS_LOB.CREATETEMPORARY(V_RESULT,TRUE,DBMS_LOB.SESSION);
  JSON_ARRAYAGG_CLOB(V_RESULT,P_ARRAY_ARRAY_ENTRIES);
  return V_RESULT;
end;
--
procedure JSON_ARRAYAGG_CLOB(P_JSON_DOCUMENT IN OUT CLOB, P_JSON_ARRAYS JSON_ARRAY_TABLE)
as
begin
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'[');  
  if (P_JSON_ARRAYS.count > 0) then
    for i in P_JSON_ARRAYS.FIRST .. P_JSON_ARRAYS.LAST loop
      if (i > 1) then DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,','); end if;  
      DBMS_LOB.APPEND(P_JSON_DOCUMENT,P_JSON_ARRAYS(i));
    end loop;
  end if;
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,']');  
end;
--
function JSON_ARRAYAGG_CLOB(P_JSON_ARRAYS JSON_ARRAY_TABLE)
return CLOB
as
  V_RESULT CLOB;
begin
  DBMS_LOB.CREATETEMPORARY(V_RESULT,TRUE,DBMS_LOB.SESSION);
  JSON_ARRAYAGG_CLOB(V_RESULT,P_JSON_ARRAYS);
  return V_RESULT;
end;
--
procedure JSON_ARRAYAGG_CLOB(P_JSON_DOCUMENT IN OUT CLOB, P_CURSOR SYS_REFCURSOR)
as
  V_SEPERATOR         VARCHAR2(1) := ',';
  V_ARRAY_MEMBER      CLOB;
  V_FIRST_MEMBER      BOOLEAN := true;
begin
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'[');  
  loop
    fetch P_CURSOR into V_ARRAY_MEMBER;
    exit when P_CURSOR%notfound;
    if (NOT V_FIRST_MEMBER) then DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length(V_SEPERATOR),V_SEPERATOR); end if;
    V_FIRST_MEMBER := false;
    DBMS_LOB.APPEND(P_JSON_DOCUMENT,V_ARRAY_MEMBER);
  end loop;
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,']');  
end;
--
function JSON_ARRAYAGG_CLOB(P_CURSOR SYS_REFCURSOR) 
return CLOB
as
  V_RESULT CLOB;
begin
  DBMS_LOB.CREATETEMPORARY(V_RESULT,TRUE,DBMS_LOB.SESSION);
  JSON_ARRAYAGG_CLOB(V_RESULT,P_CURSOR);
  return V_RESULT;
end;
--
function JSON_OBJECTAGG_CLOB(P_STATEMENT VARCHAR2)
return CLOB
as
  V_KVP_TABLE KVP_TABLE;
begin
--  select PARAMETER "KEY", C_STRING DATA_TYPE, NULL "NUMERIC_VALUE", VALUE "STRING_VALUE", NULL "CLOB_VALUE"
--    bulk collect into V_KVP_TABLE
--    from NLS_DATABASE_PARAMETERS;
  execute immediate P_STATEMENT bulk collect into V_KVP_TABLE;
  return JSON_OBJECT_CLOB(V_KVP_TABLE);
end;
--
$END
--
end;
/
--
set TERMOUT on
--
show errors
--
@@SET_TERMOUT
--
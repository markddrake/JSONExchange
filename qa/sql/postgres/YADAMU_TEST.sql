create or replace function TRUNCATE_GEOMETRY_WKT(P_GEOMETRY GEOMETRY,P_SPATIAL_PRECISION INT) returns TEXTas $$  declare X  NUMERIC(28,18);  declare Y  NUMERIC(28,18);  declare WKT TEXT;  declare RING_NUMBER INT := 0;  declare RING_COUNT INT := 0;  declare RING_SEPERATOR CHAR(1) := '';  declare POINT_id INT := 0;  declare POINT_NUMBER INT := 0;  declare POINT_COUNT INT := 0;  declare POINT_SEPERATOR CHAR(1) := '';  declare POLYGON_NUMBER INT := 0;  declare POLYGON_COUNT INT := 0;  declare POLYGON_SEPERATOR CHAR(1) := '';  declare RING GEOMETRY;  declare POINT GEOMETRY;  declare POLYGON GEOMETRY;BEGIN   WKT := GeometryType(P_GEOMETRY) ;  if (GeometryType(P_GEOMETRY) = 'POINT') then    X := trunc(ST_X(P_GEOMETRY)::NUMERIC(28,18),P_SPATIAL_PRECISION);	Y := trunc(ST_Y(P_GEOMETRY)::NUMERIC(28,18),P_SPATIAL_PRECISION);    WKT := concat('POINT(',X,' ',Y,')');    return WKT;  end if;    if (GeometryType(P_GEOMETRY) = 'POLYGON') then    WKT := concat(WKT,'(');    RING_NUMBER := 0;    RING := ST_ExteriorRing(P_GEOMETRY);    POINT_NUMBER := 0;    POINT_COUNT = ST_NPoints(RING);    WKT := concat(WKT,'(');    while (POINT_NUMBER < POINT_COUNT) loop      POINT_NUMBER := POINT_NUMBER + 1;      POINT = ST_PointN(RING,POINT_NUMBER);      X := trunc(ST_X(POINT)::NUMERIC(28,18),P_SPATIAL_PRECISION);	  Y := trunc(ST_Y(POINT)::NUMERIC(28,18),P_SPATIAL_PRECISION);	  WKT = concat(WKT,POINT_SEPERATOR,X,' ',Y);      POINT_SEPERATOR = ',';    end loop;    WKT := concat(WKT,')');      RING_NUMBER := RING_NUMBER + 1;    RING_SEPERATOR := ',';    RING_COUNT := ST_NRings(P_GEOMETRY);    while (RING_NUMBER  < RING_COUNT) loop      WKT := concat(WKT,RING_SEPERATOR,'(');      RING := ST_InteriorRingN(P_GEOMETRY,RING_NUMBER);      RING_NUMBER := RING_NUMBER + 1;      POINT_NUMBER := 0;      POINT_SEPERATOR = ' ';      POINT_COUNT = ST_NPoints(RING);      while (POINT_NUMBER < POINT_COUNT) loop        POINT_NUMBER := POINT_NUMBER + 1;        POINT = ST_PointN(RING,POINT_NUMBER);        X := trunc(ST_X(POINT)::NUMERIC(28,18),P_SPATIAL_PRECISION);	    Y := trunc(ST_Y(POINT)::NUMERIC(28,18),P_SPATIAL_PRECISION);  	    WKT = concat(WKT,POINT_SEPERATOR,X,' ',Y);        POINT_SEPERATOR = ',';      end loop;      WKT := concat(WKT,')');      end loop;     WKT := concat(WKT,')');      return WKT;  end if;  if (GeometryType(P_GEOMETRY) = 'MULTIPOLYGON') then    WKT = concat(WKT,'(');    POLYGON_NUMBER := 0;    POLYGON_SEPERATOR := '';    POLYGON_COUNT := ST_NumGeometries(P_GEOMETRY);    while (POLYGON_NUMBER  < POLYGON_COUNT) loop      WKT := concat(WKT,POLYGON_SEPERATOR,'(');      POLYGON_SEPERATOR := ',';            POLYGON_NUMBER = POLYGON_NUMBER + 1;      POLYGON = ST_GeometryN(P_GEOMETRY,POLYGON_NUMBER);      RING_NUMBER := 0;      RING := ST_ExteriorRing(POLYGON);      POINT_NUMBER := 0;      POINT_SEPERATOR = ' ';      POINT_COUNT = ST_NPoints(RING);      WKT = concat(WKT,'(');      while (POINT_NUMBER < POINT_COUNT) loop        POINT_NUMBER := POINT_NUMBER + 1;        POINT = ST_PointN(RING,POINT_NUMBER);        X := trunc(ST_X(POINT)::NUMERIC(28,18),P_SPATIAL_PRECISION);	    Y := trunc(ST_Y(POINT)::NUMERIC(28,18),P_SPATIAL_PRECISION);        WKT := concat(WKT,POINT_SEPERATOR,X,' ',Y);        POINT_SEPERATOR = ',';      end loop;      WKT := concat(WKT,')');      RING_NUMBER := RING_NUMBER + 1;      RING_COUNT := ST_NRings(POLYGON);
      RING_SEPERATOR := ',';      while (RING_NUMBER  < RING_COUNT) loop        WKT := concat(WKT,RING_SEPERATOR,'(');
        RING := ST_InteriorRingN(POLYGON,RING_NUMBER);        RING_NUMBER := RING_NUMBER + 1;        POINT_NUMBER := 0;        POINT_SEPERATOR = ' ';        POINT_COUNT := ST_NPoints(RING);        while (POINT_NUMBER < POINT_COUNT) loop          POINT_NUMBER := POINT_NUMBER + 1;          POINT := ST_PointN(RING,POINT_NUMBER);          X := trunc(ST_X(POINT)::NUMERIC(28,18),P_SPATIAL_PRECISION);	      Y := trunc(ST_Y(POINT)::NUMERIC(28,18),P_SPATIAL_PRECISION);          WKT := concat(WKT,POINT_SEPERATOR,X,' ',Y);          POINT_SEPERATOR = ',';        end loop;        WKT := concat(WKT,')');      end loop;      WKT := concat(WKT,')');    end loop;    WKT := concat(WKT,')');    return WKT;  end if;  return ST_AsTEXT(P_GEOMETRY);END; $$ LANGUAGE 'plpgsql';--create or replace procedure COMPARE_SCHEMA(P_SOURCE_SCHEMA VARCHAR,P_TARGET_SCHEMA VARCHAR,P_EMPTY_STRING_IS_NULL BOOLEAN,P_STRIP_XML_DECLARATION BOOLEAN, P_SPATIAL_PRECISION INT)as $$declare  R RECORD;  V_SQL_STATEMENT TEXT;  C_NEWLINE CHAR(1) = CHR(10);    V_SOURCE_COUNT INT;  V_TARGET_COUNT INT;  V_MISSING_ROWS INT;  V_EXTRA_ROWS   INT;  V_SQLERRM        TEXT;begin  create temporary table if not exists SCHEMA_COMPARE_RESULTS (    SOURCE_SCHEMA    VARCHAR(128)   ,TARGET_SCHEMA    VARCHAR(128)   ,TABLE_NAME       VARCHAR(128)   ,SOURCE_ROW_COUNT INT   ,TARGET_ROW_COUNT INT   ,MISSING_ROWS     INT   ,EXTRA_ROWS       INT   ,SQLERRM          TEXT  );  TRUNCATE TABLE SCHEMA_COMPARE_RESULTS;    for r in select t.table_name	             ,string_agg(                    case                       when data_type in ('character varying') then                        case                           when P_EMPTY_STRING_IS_NULL then                            'case when"' || column_name || '" = '''' then NULL else "' || column_name || '" end "' || column_name || '"'                           else                             '"' || column_name || '"'                         end                      when data_type = 'json'  then					   -- ### TODO: Size restiction on this conversion ????                        'to_jsonb("' || column_name || '")::text'                       when data_type = 'xml'  then                        case                            when P_STRIP_XML_DECLARATION then                           'regexp_replace(regexp_replace("' || column_name || '"::text,''<\?xml.*?\?>'',''''),''&apos;'','''''''',''g'')'                          else                            '"' || column_name || '"::text'                         end                      when ((data_type = 'USER-DEFINED') and (udt_name = 'geometry')) then                       case                          when P_SPATIAL_PRECISION < 18 then                           'ST_AsText("' || column_name || '",' || P_SPATIAL_PRECISION || ')'                          else                           'ST_AsEWKB("' || column_name || '")'                         end                      when ((data_type = 'USER-DEFINED') and (udt_name = 'geography')) then                       case                          when P_SPATIAL_PRECISION < 18 then                           'ST_AsText("' || column_name || '",' || P_SPATIAL_PRECISION || ')'                          else                           'ST_AsBinary("' || column_name || '")'                         end                      else                         '"' || column_name || '"'                     end                   ,','                    order by ordinal_position                  ) COLUMN_LIST	             ,string_agg(                    case                       when data_type in ('character varying') then                        case                           when P_EMPTY_STRING_IS_NULL then                            'case when"' || column_name || '" = '''' then NULL else "' || column_name || '" end "' || column_name || '"'                           else                             '"' || column_name || '"'                         end                      when data_type = 'json'  then                        '"' || column_name || '"::text'                       when data_type = 'xml'  then                        case                            when P_STRIP_XML_DECLARATION then                           'regexp_replace(regexp_replace("' || column_name || '"::text,''<\?xml.*?\?>'',''''),''&apos;'','''''''',''g'')'                          else                            '"' || column_name || '"::text'                         end                      when ((data_type = 'USER-DEFINED') and (udt_name = 'geometry')) then                        'TRUNCATE_GEOMETRY_WKT("' || column_name || '",' || P_SPATIAL_PRECISION || ')'                       when ((data_type = 'USER-DEFINED') and (udt_name = 'geography')) then                        'TRUNCATE_GEOMETRY_WKT("' || column_name || '"::geometry,' || P_SPATIAL_PRECISION || ')'                       else                         '"' || column_name || '"'                     end                   ,','                    order by ordinal_position                  ) ALT_COLUMN_LIST             from information_schema.columns c, information_schema.tables t            where t.table_name = c.table_name               and t.table_schema = c.table_schema	          and t.table_type = 'BASE TABLE'              and t.table_schema = P_SOURCE_SCHEMA            group by t.table_schema, t.table_name   loop    begin      V_SQL_STATEMENT := concat('select count(*) from "',P_SOURCE_SCHEMA,'"."',r.TABLE_NAME,'"');      EXECUTE V_SQL_STATEMENT into V_SOURCE_COUNT;         V_SQL_STATEMENT := concat('select count(*) from "',P_TARGET_SCHEMA,'"."',r.TABLE_NAME,'"');      EXECUTE V_SQL_STATEMENT into V_TARGET_COUNT;      V_SQL_STATEMENT := concat('select count(*) from (SELECT ' || r.COLUMN_LIST || ' from "' || P_SOURCE_SCHEMA  || '"."' || r.TABLE_NAME || '" EXCEPT SELECT ' || r.COLUMN_LIST || ' from  "' || P_TARGET_SCHEMA  || '"."' || r.TABLE_NAME || '") "T"');      EXECUTE V_SQL_STATEMENT into V_MISSING_ROWS;      V_SQL_STATEMENT := concat('select count(*) from (SELECT ' || r.COLUMN_LIST || ' from "' || P_TARGET_SCHEMA  || '"."' || r.TABLE_NAME || '" EXCEPT SELECT ' || r.COLUMN_LIST || ' from  "' || P_SOURCE_SCHEMA  || '"."' || r.TABLE_NAME || '") "T"');      EXECUTE V_SQL_STATEMENT into V_EXTRA_ROWS;	  if ((V_MISSING_ROWS > 0) and (V_EXTRA_ROWS > 0) and (V_MISSING_ROWS = V_EXTRA_ROWS)) then       -- RAISE INFO 'Mismatch: % % %', r.TABLE_NAME, V_MISSING_ROWS, V_EXTRA_ROWS;        V_SQL_STATEMENT := concat('select count(*) from (SELECT ' || r.ALT_COLUMN_LIST || ' from "' || P_SOURCE_SCHEMA  || '"."' || r.TABLE_NAME || '" EXCEPT SELECT ' || r.ALT_COLUMN_LIST || ' from  "' || P_TARGET_SCHEMA  || '"."' || r.TABLE_NAME || '") "T"');        EXECUTE V_SQL_STATEMENT into V_MISSING_ROWS;          V_SQL_STATEMENT := concat('select count(*) from (SELECT ' || r.ALT_COLUMN_LIST || ' from "' || P_TARGET_SCHEMA  || '"."' || r.TABLE_NAME || '" EXCEPT SELECT ' || r.ALT_COLUMN_LIST || ' from  "' || P_SOURCE_SCHEMA  || '"."' || r.TABLE_NAME || '") "T"');        EXECUTE V_SQL_STATEMENT into V_EXTRA_ROWS;       -- RAISE INFO 'Truncated: % % %', r.TABLE_NAME, V_MISSING_ROWS, V_EXTRA_ROWS;        	  end if;      insert into SCHEMA_COMPARE_RESULTS VALUES (P_SOURCE_SCHEMA, P_TARGET_SCHEMA, r.TABLE_NAME, V_SOURCE_COUNT, V_TARGET_COUNT, V_MISSING_ROWS, V_EXTRA_ROWS, NULL);    exception        when others then        V_SQLERRM = SQLERRM;        V_SOURCE_COUNT = -1;        V_TARGET_COUNT = -1;        begin           EXECUTE 'select count(*) from "' || P_SOURCE_SCHEMA  || '"."' || r.TABLE_NAME || '"' into V_SOURCE_COUNT;        exception           when others then            null;        end;                 begin           EXECUTE 'select count(*) from "' || P_TARGET_SCHEMA  || '"."' || r.TABLE_NAME || '"' into V_TARGET_COUNT;        exception           when others then            null;        end;		        insert into SCHEMA_COMPARE_RESULTS VALUES (P_SOURCE_SCHEMA, P_TARGET_SCHEMA, r.TABLE_NAME, V_SOURCE_COUNT, V_TARGET_COUNT, -1, -1, V_SQLERRM);                end;                                     end loop;end;$$ LANGUAGE plpgsql;--